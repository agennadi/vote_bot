import logging
import os
from telegram import Update, InlineQueryResultArticle, InputTextMessageContent, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import ContextTypes
from telegram.error import BadRequest
from models.poll import Poll
from services.poll_service import PollService
from utils.translations import translator

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)


async def handle_inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle inline queries for poll creation with a single form."""

    query = update.inline_query.query
    logger.info(
        f"Inline query received: '{query}' from user {update.effective_user.id}")
    
    # Store chat info for Web App button (if available)
    # Note: inline_query doesn't have chat_id, but we can try to get it from the query
    if update.inline_query.chat_type:
        # Store user_id for later use
        context.user_data['last_inline_user_id'] = update.effective_user.id

    # Always show the form interface - users can type their poll data or use examples
    await show_poll_form(update, context, query)


async def show_poll_form(update: Update, context: ContextTypes.DEFAULT_TYPE, query: str = ""):
    """Show the poll creation form as inline query results."""

    logger.info(f"Showing poll form for query: '{query}'")
    results = []

    # Always show Web App form option first (most user-friendly)
    # Note: Web App buttons can't be in inline query results, so we use a special marker
    # that will trigger sending a message with the Web App button
    webapp_url = os.getenv("WEBAPP_URL", "https://your-domain.com/webapp/index.html")
    
    # Use a special marker that we can detect in handle_poll_creation_message
    results.append(
        InlineQueryResultArticle(
            id="webapp_create_poll",
            title="ðŸ“ Create Poll with Form",
            description="Fill out a user-friendly form to create your poll",
            input_message_content=InputTextMessageContent(
                message_text="WEBAPPFORM:"  # Special marker to trigger Web App button
            )
        )
    )

    # If user has typed something, try to parse it and show preview
    if query.strip():
        poll_data = parse_poll_query(query)
        if poll_data:
            # Create trigger message that will auto-create the poll
            # Format: hidden command marker + human-readable text
            poll_command = f"CREATEPOLL:{query}"

            results.append(
                InlineQueryResultArticle(
                    id=f"create_poll_{update.inline_query.id}",
                    title="ðŸ—³ï¸ Create Poll",
                    description=f"{poll_data['question'][:60]}",
                    input_message_content=InputTextMessageContent(
                        message_text=poll_command
                    )
                )
            )

    # Always show examples
    results.extend([
        InlineQueryResultArticle(
            id="poll_example_1",
            title="ðŸ• Food Preference Poll",
            description="What's your favorite food?|Pizza|Burger|Sushi",
            input_message_content=InputTextMessageContent(
                message_text="CREATEPOLL:What's your favorite food?|Pizza|Burger|Sushi|false|true"
            )
        ),
        InlineQueryResultArticle(
            id="poll_example_2",
            title="ðŸŽ¬ Movie Night Poll",
            description="Which movie should we watch?|Action|Comedy|Horror",
            input_message_content=InputTextMessageContent(
                message_text="CREATEPOLL:Which movie should we watch?|Action|Comedy|Horror|true|false|50"
            )
        ),
        InlineQueryResultArticle(
            id="poll_example_3",
            title="ðŸŽ¨ Color Preference Poll",
            description="What's your favorite color?|Red|Blue|Green|Yellow",
            input_message_content=InputTextMessageContent(
                message_text="CREATEPOLL:What's your favorite color?|Red|Blue|Green|Yellow|false|true|100"
            )
        ),
        InlineQueryResultArticle(
            id="poll_help",
            title="ðŸ“ How to Create Polls",
            description="Format: question|option1|option2|anonimity|forwarding|limit",
            input_message_content=InputTextMessageContent(
                message_text="""ðŸ“ **How to Create Polls**

Use this format: `question|option1|option2|option3|anonimity|forwarding|limit`

**Parameters:**
â€¢ **question**: Your poll question
â€¢ **option1, option2, etc.**: Poll options (minimum 2)
â€¢ **anonimity**: true/false (default: false)
â€¢ **forwarding**: true/false (default: true) 
â€¢ **limit**: max voters (optional, default: unlimited)

**Examples:**
â€¢ `What's your favorite food?|Pizza|Burger|Sushi|false|true`
â€¢ `Which movie should we watch?|Action|Comedy|Horror|true|false|50`
â€¢ `What's your favorite color?|Red|Blue|Green|Yellow|false|true|100`

Just type your poll data after @yourbot and select the result!""",
                parse_mode='Markdown'
            )
        )
    ])

    logger.info(f"Sending {len(results)} results to inline query")
    await update.inline_query.answer(results, cache_time=1)


def parse_poll_query(query: str) -> dict:
    """Parse the inline query to extract poll parameters."""

    parts = [part.strip() for part in query.split('|')]

    if len(parts) < 3:  # Need at least question + 2 options
        return None

    try:
        poll_data = {
            'question': parts[0],
            # All middle parts are options
            'options': parts[1:-3] if len(parts) > 5 else parts[1:],
            'anonimity': False,
            'forwarding': True,
            'limit': None
        }

        # Parse optional parameters from the end
        if len(parts) >= 5:
            # Check if last part is a number (limit)
            try:
                poll_data['limit'] = int(parts[-1])
                remaining_parts = parts[:-1]
            except ValueError:
                remaining_parts = parts

            # Parse anonimity and forwarding
            if len(remaining_parts) >= 4:
                poll_data['anonimity'] = remaining_parts[-2].lower() == 'true'
                poll_data['forwarding'] = remaining_parts[-1].lower() == 'true'
                poll_data['options'] = remaining_parts[1:-2]

        # Validate minimum options
        if len(poll_data['options']) < 2:
            return None

        return poll_data

    except Exception as e:
        logger.error(f"Error parsing poll query: {e}")
        return None


async def handle_chosen_inline_result(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle when user selects an inline query result."""
    logger.info("=== handle_chosen_inline_result CALLED ===")
    chosen_result = update.chosen_inline_result
    logger.info(f"Chosen inline result: {chosen_result.result_id}")
    try:
        logger.info(f"Chosen result details: from_user={chosen_result.from_user.id}, query={chosen_result.query}, inline_message_id={chosen_result.inline_message_id}")
    except Exception as e:
        logger.warning(f"Could not log chosen result details: {e}")
    
    # If Web App form was selected, don't send anything here
    # The "WEBAPPFORM:" message will be handled by handle_poll_creation_message
    # which will send the button in the correct chat (group or private)
    if chosen_result.result_id == "webapp_create_poll":
        logger.info("Web App form result selected - WEBAPPFORM: message will be handled by handle_poll_creation_message")
        return

async def handle_poll_creation_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Detect and handle CREATEPOLL: messages and WEBAPPFORM: markers."""

    message_text = update.message.text
    logger.info(f"handle_poll_creation_message called with text: '{message_text}' from chat {update.effective_chat.id}")

    if not message_text:
        logger.debug("No message text, returning")
        return
    
    # Handle Web App form trigger
    if message_text.strip() == "WEBAPPFORM:" or message_text.strip().startswith("WEBAPPFORM:"):
        logger.info(f"WEBAPPFORM detected in message: '{message_text}'")
        webapp_url = os.getenv("WEBAPP_URL", "https://your-domain.com/webapp/index.html")
        logger.info(f"Web App URL from env: {webapp_url}")
        
        # Check if URL is configured
        if webapp_url == "https://your-domain.com/webapp/index.html":
            logger.warning("Web App URL not configured")
            user = update.effective_user
            error_msg = translator.translate("error_occurred", user)
            await update.message.reply_text(
                f"{error_msg}\n\nâš ï¸ Web App URL not configured. Please set WEBAPP_URL in your environment variables."
            )
            # Try to delete the trigger message
            try:
                await update.message.delete()
            except:
                pass
            return
        
        # Stack Overflow solution: Use URL button with Mini App
        # Mini App URL format: https://t.me/botusername/miniappname
        # Get Mini App URL from environment (set via BotFather)
        mini_app_url = os.getenv("MINI_APP_URL", "")
        
        if not mini_app_url:
            logger.warning("MINI_APP_URL not configured. Please create a Mini App via @BotFather and set MINI_APP_URL")
            user = update.effective_user
            error_msg = translator.translate("error_occurred", user)
            await update.message.reply_text(
                f"{error_msg}\n\nâš ï¸ Mini App URL not configured. Please set MINI_APP_URL in your environment variables."
            )
            try:
                await update.message.delete()
            except:
                pass
            return
        
        # Add chat_id as query parameter if in group
        chat_id = update.effective_chat.id
        is_group = update.effective_chat.type in ["group", "supergroup"]
        
        if is_group:
            # Add group chat_id to URL
            from urllib.parse import urlencode, urlparse, urlunparse
            parsed = urlparse(mini_app_url)
            query_params = {"chat_id": chat_id}
            # Merge with existing query params if any
            existing_params = {}
            if parsed.query:
                from urllib.parse import parse_qs
                existing_params = {k: v[0] for k, v in parse_qs(parsed.query).items()}
            existing_params.update(query_params)
            mini_app_url_with_chat = urlunparse((
                parsed.scheme, parsed.netloc, parsed.path,
                parsed.params, urlencode(existing_params), parsed.fragment
            ))
        else:
            mini_app_url_with_chat = mini_app_url
        
        # Use InlineKeyboardButton with URL (works in both groups and private chats!)
        button = InlineKeyboardButton(
            text="ðŸ“ Open Poll Creation Form",
            url=mini_app_url_with_chat
        )
        keyboard = InlineKeyboardMarkup([[button]])
        
        form_message = "ðŸ“ Click the button below to open the poll creation form!"
        
        # Send the button - works in both groups and private chats!
        try:
            sent_message = await update.message.reply_text(
                text=form_message,
                reply_markup=keyboard
            )
            logger.info(f"Sent Mini App URL button in chat {update.effective_chat.id}")
            
            # Try to delete the WEBAPPFORM trigger message
            try:
                await update.message.delete()
                logger.debug("Successfully deleted WEBAPPFORM trigger message")
            except BadRequest as e:
                logger.debug(f"Cannot delete WEBAPPFORM message (may not have permission): {e}")
            except Exception as e:
                logger.debug(f"Error deleting WEBAPPFORM message: {e}")
        except Exception as e:
            logger.error(f"Could not send Mini App URL button: {e}", exc_info=True)
        
        return
